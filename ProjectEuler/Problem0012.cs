using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ProjectEuler
{
    internal class Problem0012 : Problem
    {
        protected override uint Number => 12;

        protected override string GetPrompt()
        {
            return @"The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?";
        }

        protected override string Solve()
        {
            /*
             * The question for this problem made me gasp...
             * 
             * First thing, we need a way to find triangle numbers, as well as their factors. Maybe not their factors exactly, but at least a count of how many there are.
             * The triangle numbers should be easy to find, as we can just keep adding to the same variable over each iteration.
             * 
             * Finding factors also gives off a Problem 3 vibe, but it isn't quite the same. It is similar, as we will go from 1 to the sqrt of the number. Except,
             * this time, we can stop at the sqrt and multiply by 2, as all we need is the raw number of factors, we don't need to know the values.
             */

            ulong count = 500;

            ulong triangleNumber = 0;
            ulong index = 1;
            ulong factorCount = 0;

            ulong i;

            while(factorCount <= count)
            {
                triangleNumber += index;
                factorCount = 1;//every number (except 1) has 2 factors. 1 and itself.
                index++;

                //if the triangle number is odd, we can skip it. Odds are (pun intended), the value will be even
                if(triangleNumber % 2 != 0)
                {
                    continue;
                }

                //go to square root, as after that, all you find is the other half of the pairs
                for (i = 2; i <= (ulong)Math.Sqrt(triangleNumber); i++)
                {
                    if(triangleNumber % i == 0)
                    {
                        //factor found
                        factorCount++;
                    }
                }

                //multiply factor count by 2 to account for the other half
                factorCount <<= 1;

                //loop should end once ample number of factors found
            }

            return triangleNumber.ToString();
        }
    }
}
